---
title: "Project Documentation"
output: html_notebook
---
Feb 14th
```{r}
parse_date("4/1/2015", "%m/%d/%Y")
# parses our date successfully

parse_time("0:21:00")
```
```{r}
# This is for future reference, for now we are good.
uber$date <- as.Date(data$Date/Time) # add date column
uber$time <- format(as.POSIXct(data$Date/Time),format = "%H:%M:%S") # add time column
# source: https://statisticsglobe.com/split-date-time-column-into-separate-variables-in-r

```

Feb 16th

4:00 pm to 5 pm: working on tidying data and writing cleaned dataset to a new file. 


```{r}
# separating date and time from Date/Time column

new_uber <- uber %>%
  separate('Date/Time', into = c("date", "time"), sep = " ")
```

Feb 17th
10 am to 11 am installed ggmap, set up Google cloud account and set up the api key.

Ran into this error when playing around: Discrete value supplied to continuous scale. This happens when applying aes to a categorical value when I put the column name in quotes.

Also ran into a problem where get_map() requires additional API authorization but it is resolved by lifting the restriction from the cloud platform.

```{r}
ggmap(nyc_map) + 
    geom_point(data = uber, aes(x= Lon,y= Lat), size=0.15,alpha=.3)
```
```{r}
#Run this line before using ggmap
register_google(key = "AIzaSyAnGi82u7r4pOg8fYXC_dugPcMeiA2OMf8")
```

```{r}
nyc.map <- get_map(location= 'Lower Manhattan, New York', 
                       maptype='roadmap', color='color',source='google',zoom=14)

ggmap(nyc.map) + 
    geom_point(data = uber, aes(x= Lon,y= Lat), size=0.15,alpha=.3)
```

Feb 18th
In-class: worked on connecting slider bar input to the zoom ratio to change the map zoom specification.

4 pm to 4:30 pm: working on changing the date format and creating the reactive component of my shiny app.
```{r}
# changed the date format to accomendate sliderInput in Shiny
new_uber <- uber %>%
  separate('Date/Time', into = c("date", "time"), sep = " ") %>%
  mutate(date = mdy(date))
```

I was looking into how to connect the date range input to the dataset, but was having a little trouble doing that, might need more research. 
```{r}
server <- function(input, output) {

    output$pickupPlot <- renderPlot({
        nyc.map <- get_map(location= 'Lower Manhattan, New York', 
                           maptype='roadmap', color='color',source='google', zoom = input$zoom)
        
        ggmap(nyc.map) + 
            geom_point(data = uber, aes(x= Lon,y= Lat), size=0.3,alpha=.3)
        # specifically select 'uber' based on the date from the input.
        
    })
}
```

Feb 19th

2:30pm-3pm
Playing around with printing the date range using dateRangeinput from Shiny app demo page

8:30pm-9:30pm
Working on selecting my dataset based on date range and apply to the ploting. 
```{r}
#testing selectByDate
output$dateRangeText  <- renderPrint({
        start_date <- format(input$dateRange[1], "%Y-%m-%d")
        end_date <- format(input$dateRange[2], "%Y-%m-%d")
        selectByDate(uber, start = start_date, end = end_date)
    })
# renderPlot
output$pickupPlot <- renderPlot({
        start_date <- format(input$dateRange[1], "%Y-%m-%d")
        end_date <- format(input$dateRange[2], "%Y-%m-%d")
        uberWithDate <- selectByDate(uber, start = start_date, end = end_date, month = c(5, 6), day = 1:31)
        
        nyc.map <- get_map(location= 'Lower Manhattan, New York',
                           maptype='roadmap', color='color',source='google', zoom = input$zoom)

        ggmap(nyc.map) +
            geom_point(data = uberWithDate, aes(x= Lon,y= Lat), size=0.3,alpha=.3)
    })
```

Next thing I want to work on is make each data point clicable or interactive. 

2/21
9-9:30pm: researching on how to make ggmap interactive and learned more about reactivity. Found a library called googleway.

2/22
8:30-9:30am: found leaflet and played around with it. I made a new shiny app to accommodate the new package and shinydashboard. 
```{r}
library(leaflet)

m <- leaflet("New York City") %>%
  addTiles() %>%  # Add default OpenStreetMap map tiles
  addMarkers(lng=-90.321, lat=40.31, popup="The birthplace of R")
m  # Print the map
```
2/26
4-5pm: went to Mingi's Mentor session and worked on mutating the data to show Uber pickups in different regions. 

2/27
12:30 - 3pm: working on leaflet and made a basic choropleth map of NYC
```{r}
library(tigris)
library(dplyr)
library(leaflet)

# Downloading the shapefiles for states at the lowest resolution
nyc <- county_subdivisions("New York", c("Bronx", "Kings", "New York", "Queens", "Richmond"))

nyc %>%
  leaflet() %>%
  addTiles() %>%
  addPolygons(popup=~NAME)
```

7-9pm: clean data to add a county column using latlong2country
9:30-11pm: working on joining spatial file with data frame
source: https://stackoverflow.com/questions/13316185/r-convert-zipcode-or-lat-long-to-county
```{r}
library(sp)
library(dplyr)
library(stringr)
library(maps)
library(maptools)

# The single argument to this function, pointsDF, is a data.frame in which:
#   - column 1 contains the longitude in degrees (negative in the US)
#   - column 2 contains the latitude in degrees

latlong2county <- function(pointsDF) {
    # Prepare SpatialPolygons object with one SpatialPolygon
    # per county
    counties <- maps::map('county', fill=TRUE, col="transparent", plot=FALSE)
    IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
    counties_sp <- map2SpatialPolygons(counties, IDs=IDs,
                     proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Convert pointsDF to a SpatialPoints object 
    pointsSP <- SpatialPoints(pointsDF, 
                    proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Use 'over' to get _indices_ of the Polygons object containing each point 
    indices <- over(pointsSP, counties_sp)
    
    # Return the county names of the Polygons object containing each point
    countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
    result <- c(countyNames[indices])
    word(result, 2, sep = fixed(","))
}

# Test the function using points in Wisconsin and Oregon.
testPoints <- data.frame(x = c(-90, -120), y = c(44, 44))

latlong2county(as.data.frame(head(select(uber, c("Lon", "Lat")))))
```
Ran into this problem where tidyverse also has a function map, so we need to use maps::map

```{r}
library(tidyverse)
library(sp)
library(dplyr)
library(tigris)
library(leaflet)
library(stringr)
library(maps)
library(maptools)

#uber <- read_csv("uber_county.csv")
#nyc <- county_subdivisions("New York", c("Bronx", "Kings", "New York", "Queens", "Richmond"))
all_counties <- filter(counties("New York"), NAME %in% c("Bronx", "Kings", "New York", "Queens", "Richmond"))
nyc <- mutate(all_counties, name = tolower(all_counties$NAME))

nyc_county <- uber %>%
  filter(counties %in% c("bronx", "kings", "new york", "queens", "richmond")) %>%
  group_by(counties) %>%
  summarize(total=n())



# glimpse(nyc_county)

# Now we use the Tigris function geo_join to bring together 
# the states shapefile and the sb_states dataframe -- STUSPS and state 
# are the two columns they'll be joined by

merged <- left_join(nyc, nyc_county, by = c("name" = "counties"))
glimpse(merged)
# Creating a color palette based on the number range in the total column
pal <- colorNumeric("Greens", merged$total)
 

# # Getting rid of rows with NA values
# # Using the Base R method of filtering subset() because we're dealing with a SpatialPolygonsDataFrame and not a normal data frame, thus filter() wouldn't work
# 
merged <- subset(merged, !is.na(total))

# Setting up the pop up text
popup_sb <- paste0("Total pickups in ", as.character(merged$NAME)," : ", as.character(merged$total))
leaflet(merged) %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  setView(-73.9, 40.7, zoom = 10) %>%
  addPolygons(data = merged,
              fillColor = ~pal(merged$total),
              fillOpacity = 0.7,
              weight = 0.2,
              smoothFactor = 0.2,
              popup = ~popup_sb) %>%
  addLegend(
            "bottomright",
            pal = pal,
            values = merged$total,
            title = "Pickups frequency")
#sum(is.na(new_uber$counties))
```

Next: 


